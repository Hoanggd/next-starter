---
title: Philosophy
description: Our guiding principles for building maintainable, performant, and beautiful user interfaces
---

> Our approach to building user interfaces is guided by a simple principle: **simplicity over complexity**. We believe that the best code is the code that's easiest to understand, maintain, and modify. This philosophy influences every decision we make, from component architecture to state management.

## Write Simple, Stupid Code

> "The best code isn't the most elegant or sophisticated - it's the code that future developers (including yourself) can understand quickly." - [Cognitive Load Theory](https://github.com/zakirullin/cognitive-load)

We prioritize **cognitive load reduction** above all else. Every line of code should be immediately understandable to any developer on the team. This means:

- **Avoid clever solutions** - If you need to explain your code to someone, it's probably too complex
- **Favor explicit over implicit** - Magic is great in fantasy novels, terrible in codebases
- **Prefer obvious over elegant** - Code that reads like plain English is better than code that's "clever"

### Example: Simple vs. Complex

```tsx
// ❌ Complex - requires mental parsing
const processData = (data) => data
  .filter(x => x.status === 'active')
  .map(x => ({ ...x, processed: true }))
  .reduce((acc, x) => ({ ...acc, [x.id]: x }), {});

// ✅ Simple - immediately clear
const activeItems = data.filter(item => item.status === 'active');
const processedItems = activeItems.map(item => ({
  ...item,
  processed: true
}));
const itemsById = {};
for (const item of processedItems) {
   itemsById[item.id] = item;
}
```

## Avoid Hasty Abstractions

> "Prefer duplication over the wrong abstraction" - [Sandi Metz](https://kentcdodds.com/blog/aha-programming)

Following the **AHA Programming** principle (Avoid Hasty Abstractions), we believe that code duplication is often preferable to premature abstraction. Here's why:

- **Duplication is obvious** - You can see exactly what's happening
- **Wrong abstractions are expensive** - They create complexity that's hard to unwind
- **Patterns emerge naturally** - After you've written similar code 2-3 times, the right abstraction becomes clear
- **Change is easier** - Modifying duplicated code is straightforward; modifying wrong abstractions requires understanding the entire system

### When to Abstract

- ✅ **After 2-3 instances** of similar code
- ✅ **When the pattern is stable** and unlikely to change
- ✅ **When the abstraction is obvious** to the entire team
- ❌ **Before you understand** the full scope of use cases
- ❌ **To satisfy DRY dogma** without clear benefits

## Limit useEffect Usage

> "Effects are an escape hatch from React's paradigm." - [React Documentation](https://react.dev/learn/you-might-not-need-an-effect)

`useEffect` is powerful but dangerous. It's often a sign that you're fighting React's declarative nature. We prefer alternatives:

### Prefer These Over useEffect

```tsx
// ❌ useEffect for derived state
const [fullName, setFullName] = useState('');
useEffect(() => {
  setFullName(`${firstName} ${lastName}`);
}, [firstName, lastName]);

// ✅ Derived state
const fullName = `${firstName} ${lastName}`;

// ❌ useEffect for API calls on mount
useEffect(() => {
  fetchUserData();
}, []);

// ✅ Server components or data fetching libraries (Tanstack Query)
```

### When useEffect is Acceptable

- **Synchronizing with external systems** (browser APIs, third-party libraries)
- **Cleanup operations** (subscriptions, timers, event listeners)
- **Logging and analytics** that can't be handled declaratively

## Prefer URL State Over Global State

Global state management libraries (Zustand, Redux, Context) create invisible dependencies that make code harder to understand and test. Instead, we prefer:

### URL as State Container

```tsx
// ❌ Global state
const { searchQuery } = useSearchStore();
const { currentPage } = usePaginationStore();

// ✅ URL state with nuqs
import { useQueryState, parseAsInteger } from 'nuqs';

const [searchQuery, setSearchQuery] = useQueryState('q', { defaultValue: '' });
const [page, setPage] = useQueryState('page', parseAsInteger.withDefault(1));
```

### Benefits of URL State

- **Shareable** - Users can bookmark and share specific states
- **Debuggable** - You can see the app app state in the browser
- **Testable** - Easy to test different states by changing URLs
- **Predictable** - State changes are visible and trackable
- **SEO friendly** - Search engines can understand your app state
- **Type-safe** - With [nuqs](https://nuqs.47ng.com/), you get end-to-end type safety
- **Simple API** - React.useState-like syntax that syncs with the URL automatically

### When Global State is Acceptable

- **UI-only state** that shouldn't be in the URL (modals, dropdowns)
- **Theme preferences** (light/dark mode, color schemes)
- **Layout configuration** (sidebar collapsed state, panel sizes, view preferences)

## Write Pixel-Perfect UI

Attention to detail matters. Users notice when interfaces are polished and professional. We strive for:

### Visual Precision

- **Exact spacing** - Use design tokens, not arbitrary values
- **Perfect alignment** - Everything should line up on a consistent grid
- **Smooth animations** - 60fps transitions with proper easing
- **Responsive design** - Works perfectly on all screen sizes
- **Accessibility** - WCAG 2.1 AA compliance minimum

### Implementation Details

```tsx
// ❌ Arbitrary values
<div style={{ margin: '10px', padding: '15px' }}>

// ✅ Design tokens
<div className="space-y-4 p-6">

// ❌ Hardcoded colors
<div style={{ color: '#ff0000' }}>

// ✅ Semantic color tokens
<div className="text-destructive">
```

## Summary

Our philosophy can be distilled into these core principles:

1. **Simplicity first** - Reduce cognitive load at every opportunity
2. **Embrace duplication** - Wait for patterns to emerge naturally
3. **Minimize side effects** - Prefer declarative over imperative
4. **URL as state** - Make app state visible and shareable with [nuqs](https://nuqs.47ng.com/)
5. **Pixel perfection** - Attention to detail builds trust

Remember: **The best code is the code that's easiest to change.** When in doubt, choose the simpler option. You can always make it more sophisticated later, but it's much harder to simplify complex code.

---

*"Any fool can write code that a computer can understand. Good programmers write code that humans can understand."* - Martin Fowler
