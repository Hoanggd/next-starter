---
title: Philosophy
description: Our guiding principles for building maintainable, performant, and beautiful user interfaces
---

> Our approach to building user interfaces is guided by a simple principle: **simplicity over complexity**. We believe that the best code is the code that's easiest to understand, maintain, and modify. This philosophy influences every decision we make, from component architecture to state management.

## Write Simple, Stupid Code

> The best code isn't the most elegant or sophisticated - it's the code that future developers (including yourself) can understand quickly. - [Cognitive Load Theory](https://github.com/zakirullin/cognitive-load)

We prioritize **cognitive load reduction** above all else. Every line of code should be immediately understandable to any developer on the team. This means:

- **Avoid clever solutions** - If you need to explain your code to someone, it's probably too complex
- **Favor explicit over implicit** - Magic is great in fantasy novels, terrible in codebases
- **Prefer obvious over elegant** - Code that reads like plain English is better than code that's "clever"

### Example: Simple vs. Complex

```js
// ‚ùå Complex
if val > someConstant // üß†+
    && (condition2 || condition3) // üß†+++, prev cond should be true, one of c2 or c3 has be true
    && (condition4 && !condition5) { // ü§Ø, we are messed up by this point
    ...
}

// ‚úÖ Simple
isValid = val > someConstant
isAllowed = condition2 || condition3
isSecure = condition4 && !condition5 
// üß†, we don't need to remember the conditions, there are descriptive variables
if isValid && isAllowed && isSecure {
    ...
}
```

### Example: "Clever" vs. "Stupid"
```js
// ‚ùå "Clever" - looks like magic
const isEven = n => !(n & 1);

// ‚úÖ "Stupid" - obvious
function isEven(n) {
  return n % 2 === 0;
}
```

## Avoid Hasty Abstractions

> Prefer duplication over the wrong abstraction - [Sandi Metz](https://kentcdodds.com/blog/aha-programming)

Following the **AHA Programming** principle (Avoid Hasty Abstractions), we believe that code duplication is often preferable to premature abstraction. Here's why:

- **Duplication is obvious** - You can see exactly what's happening
- **Wrong abstractions are expensive** - They create complexity that's hard to unwind
- **Patterns emerge naturally** - After you've written similar code 2-3 times, the right abstraction becomes clear
- **Change is easier** - Modifying duplicated code is straightforward; modifying wrong abstractions requires understanding the entire system

### When to Abstract

- ‚úÖ **After 2-3 instances** of similar code
- ‚úÖ **When the pattern is stable** and unlikely to change
- ‚úÖ **When the abstraction is obvious** to the entire team
- ‚ùå **Before you understand** the full scope of use cases
- ‚ùå **To satisfy DRY dogma** without clear benefits

## Limit useEffect Usage

> "Effects are an escape hatch from React's paradigm." - [React Documentation](https://react.dev/learn/you-might-not-need-an-effect)

`useEffect` is powerful but dangerous. It's often a sign that you're fighting React's declarative nature. We prefer alternatives:

### Prefer These Over useEffect

```tsx
// ‚ùå useEffect for derived state
const [fullName, setFullName] = useState('');
useEffect(() => {
  setFullName(`${firstName} ${lastName}`);
}, [firstName, lastName]);

// ‚úÖ Derived state
const fullName = `${firstName} ${lastName}`;

// ‚ùå useEffect for API calls on mount
useEffect(() => {
  fetchUserData();
}, []);

// ‚úÖ Server components or data fetching libraries (Tanstack Query)
```

### When useEffect is Acceptable

- **Synchronizing with external systems** (browser APIs, third-party libraries)
- **Cleanup operations** (subscriptions, timers, event listeners)
- **Logging and analytics** that can't be handled declaratively

## Prefer URL State Over Global State

Global state management libraries (Zustand, Redux, Context) create invisible dependencies that make code harder to understand and test. Instead, we prefer:

### URL as State Container

```tsx
// ‚ùå Global state
const { searchQuery } = useSearchStore();
const { currentPage } = usePaginationStore();

// ‚úÖ URL state with nuqs
import { useQueryState, parseAsInteger } from 'nuqs';

const [searchQuery, setSearchQuery] = useQueryState('q', { defaultValue: '' });
const [page, setPage] = useQueryState('page', parseAsInteger.withDefault(1));
```

### Benefits of URL State

- **Shareable** - Users can bookmark and share specific states
- **Debuggable** - You can see the app app state in the browser
- **Testable** - Easy to test different states by changing URLs
- **Predictable** - State changes are visible and trackable
- **SEO friendly** - Search engines can understand your app state
- **Type-safe** - With [nuqs](https://nuqs.47ng.com/), you get end-to-end type safety
- **Simple API** - React.useState-like syntax that syncs with the URL automatically

### When Global State is Acceptable

- **UI-only state** that shouldn't be in the URL (modals, dropdowns)
- **Theme preferences** (light/dark mode, color schemes)
- **Layout configuration** (sidebar collapsed state, panel sizes, view preferences)

## Write Pixel-Perfect UI

Attention to detail matters. Users notice when interfaces are polished and professional. We strive for:

### Visual Precision

- **Exact spacing** - Use design tokens, not arbitrary values
- **Perfect alignment** - Everything should line up on a consistent grid
- **Smooth animations** - 60fps transitions with proper easing
- **Responsive design** - Works perfectly on all screen sizes
- **Accessibility** - WCAG 2.1 AA compliance minimum

### Implementation Details

```tsx
// ‚ùå Arbitrary values
<div style={{ margin: '10px', padding: '15px' }}>

// ‚úÖ Design tokens
<div className="space-y-4 p-6">

// ‚ùå Hardcoded colors
<div style={{ color: '#ff0000' }}>

// ‚úÖ Semantic color tokens
<div className="text-destructive">
```

## Summary

Our philosophy can be distilled into these core principles:

1. **Simplicity first** - Reduce cognitive load at every opportunity
2. **Embrace duplication** - Wait for patterns to emerge naturally
3. **Minimize side effects** - Prefer declarative over imperative
4. **URL as state** - Make app state visible and shareable with [nuqs](https://nuqs.47ng.com/)
5. **Pixel perfection** - Attention to detail builds trust

Remember: **The best code is the code that's easiest to change.** When in doubt, choose the simpler option. You can always make it more sophisticated later, but it's much harder to simplify complex code.
